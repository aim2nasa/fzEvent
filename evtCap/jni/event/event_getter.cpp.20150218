/* 
 * name: event recorder 
 * date: 2015-01-30
 * author: parksunghwa
 *
 * NOTE:
 * 2015.01.30. parksunghwa, device id write 관련 문제 생길 경우 변경 필요함
 *
 */
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <unistd.h>
#include <dirent.h>
#include <signal.h>
#include <fcntl.h>

#include <errno.h>
#include <sys/types.h>
#include <sys/poll.h>
#include <sys/inotify.h>

#include <linux/input.h>

#ifndef PATH_MAX
#define PATH_MAX 4096
#endif

static struct pollfd *ufds;
static char **device_names;
static int nfds;

static int save_file;
static int close_signal;

enum {
	PRINT_DEVICE_ERRORS     = 1U << 0,
	PRINT_DEVICE            = 1U << 1,
	PRINT_DEVICE_NAME       = 1U << 2,
	PRINT_DEVICE_INFO       = 1U << 3,
	PRINT_VERSION           = 1U << 4,
	PRINT_POSSIBLE_EVENTS   = 1U << 5,
	PRINT_INPUT_PROPS       = 1U << 6,
	PRINT_HID_DESCRIPTOR    = 1U << 7,

	PRINT_ALL_INFO          = (1U << 8) - 1,

	PRINT_LABELS            = 1U << 16,
};

static void signal_handler(int signal, siginfo_t *info, void *reserved)
{
	printf("recv exit signal\n");
	close_signal = 1;
}
static int add_signal()
{
	struct sigaction handler;
	memset(&handler, 0, sizeof(handler));

	handler.sa_sigaction = signal_handler;
	handler.sa_flags = SA_RESETHAND;
	
	if(sigaction(SIGINT, &handler, 0) < 0) {
		fprintf(stdout, "sigaction failure\n");
		return 1;
	}

	return 0;
}

static int event_file_close()
{
	if(save_file) {
		close(save_file);
		save_file = 0;
	}

	return 0;
}

static int event_file_open(const char* path)
{
	save_file = open(path, O_CREAT | O_TRUNC | O_WRONLY, 0777);
	if(!save_file)
		return 1;

	return 0;	
}

static int event_file_write(const struct input_event* event, const unsigned char dev)
{
	static unsigned char _zero = 0x00;
	//int ret;
	//int total_write;

	//total_write = 0;

	//ret = 
		write(save_file, &_zero,				sizeof(_zero)); 
	//total_write += ret;
	//ret = 
		write(save_file, &event->time.tv_sec,	sizeof(event->time.tv_sec)); 
	//total_write  += ret;
	//ret = 
		write(save_file, &event->time.tv_usec,	sizeof(event->time.tv_usec)); 
	//total_write  += ret;
	//ret = 
		write(save_file, &dev,					sizeof(dev)); 
	//total_write  += ret;
	//ret = 
		write(save_file, &event->type,			sizeof(event->type)); 
	//total_write  += ret;
	//ret = 
		write(save_file, &event->code,			sizeof(event->code));
	//total_write  += ret;
	//ret = 
		write(save_file, &event->value,			sizeof(event->value));
	//total_write  += ret;
	//ret = 
		write(save_file, &_zero,				sizeof(_zero));
	//total_write  += ret;

	//printf("write %d bytes...\n", total_write);
	return 0;
}

static int open_device(const char *device, int print_flags)
{
	int version;
	int fd;
	int clkid = CLOCK_MONOTONIC;
	struct pollfd *new_ufds;
	char **new_device_names;
	char name[80];
	char location[80];
	char idstr[80];
	struct input_id id;

	fd = open(device, O_RDWR);
	if(fd < 0) {
		if(print_flags)
			fprintf(stderr, "could not open %s, %s\n", device, strerror(errno));
		return -1;
	}

	if(ioctl(fd, EVIOCGVERSION, &version)) {
		if(print_flags)
			fprintf(stderr, "could not get driver version for %s, %s\n", device, strerror(errno));
		return -1;
	}
	if(ioctl(fd, EVIOCGID, &id)) {
		if(print_flags)
			fprintf(stderr, "could not get driver id for %s, %s\n", device, strerror(errno));
		return -1;
	}
	name[sizeof(name) - 1] = '\0';
	location[sizeof(location) - 1] = '\0';
	idstr[sizeof(idstr) - 1] = '\0';
	name[sizeof(name) - 1] = '\0';
	location[sizeof(location) - 1] = '\0';
	idstr[sizeof(idstr) - 1] = '\0';
	if(ioctl(fd, EVIOCGNAME(sizeof(name) - 1), &name) < 1) {
		fprintf(stderr, "could not get device name for %s, %s\n", device, strerror(errno));
		name[0] = '\0';
	}
	if(ioctl(fd, EVIOCGPHYS(sizeof(location) - 1), &location) < 1) {
		fprintf(stderr, "could not get location for %s, %s\n", device, strerror(errno));
		location[0] = '\0';
	}
	if(ioctl(fd, EVIOCGUNIQ(sizeof(idstr) - 1), &idstr) < 1) {
		fprintf(stderr, "could not get idstring for %s, %s\n", device, strerror(errno));
		idstr[0] = '\0';
	}

	if (ioctl(fd, EVIOCSCLOCKID, &clkid) != 0) {
		fprintf(stderr, "Can't enable monotonic clock reporting: %s\n", strerror(errno));
	}

	new_ufds = (struct pollfd*)realloc(ufds, sizeof(ufds[0]) * (nfds + 1));
	if(new_ufds == NULL) {
		fprintf(stderr, "out of memory\n");
		return -1;
	}
	ufds = new_ufds;
	new_device_names = (char**)realloc(device_names, sizeof(device_names[0]) * (nfds + 1));
	if(new_device_names == NULL) {
		fprintf(stderr, "out of memory\n");
		return -1;
	}
	device_names = new_device_names;

	if(print_flags)
		printf("add device %d: %s\n", nfds, device);
	if(print_flags)
		printf("  bus:      %04x\n"
				"  vendor    %04x\n"
				"  product   %04x\n"
				"  version   %04x\n",
				id.bustype, id.vendor, id.product, id.version);
	if(print_flags)
		printf("  name:     \"%s\"\n", name);
	if(print_flags)
		printf("  location: \"%s\"\n"
				"  id:       \"%s\"\n", location, idstr);
	if(print_flags)
		printf("  version:  %d.%d.%d\n",
				version >> 16, (version >> 8) & 0xff, version & 0xff);

#if 0
	if(print_flags & PRINT_POSSIBLE_EVENTS) {
		print_possible_events(fd, print_flags);
	}

	if(print_flags & PRINT_INPUT_PROPS) {
		print_input_props(fd);
	}
	if(print_flags & PRINT_HID_DESCRIPTOR) {
		print_hid_descriptor(id.bustype, id.vendor, id.product);
	}
#endif

	ufds[nfds].fd = fd;
	ufds[nfds].events = POLLIN;
	device_names[nfds] = strdup(device);
	nfds++;

	return 0;
}

int close_device(const char *device, int print_flags)
{
	int i;
	for(i = 1; i < nfds; i++) {
		if(strcmp(device_names[i], device) == 0) {
			int count = nfds - i - 1;
			if(print_flags)
				printf("remove device %d: %s\n", i, device);
			free(device_names[i]);
			memmove(device_names + i, device_names + i + 1, sizeof(device_names[0]) * count);
			memmove(ufds + i, ufds + i + 1, sizeof(ufds[0]) * count);
			nfds--;
			return 0;
		}
	}
	if(print_flags)
		fprintf(stderr, "remote device: %s not found\n", device);
	return -1;
}


static int scan_dir(const char *dirname, int print_flags)
{
	char devname[PATH_MAX];
	char *filename;
	DIR *dir;
	struct dirent *de;
	dir = opendir(dirname);
	if(dir == NULL)
		return -1;
	strcpy(devname, dirname);
	filename = devname + strlen(devname);
	*filename++ = '/';
	while((de = readdir(dir))) {
		if(de->d_name[0] == '.' &&
				(de->d_name[1] == '\0' ||
				 (de->d_name[1] == '.' && de->d_name[2] == '\0')))
			continue;
		strcpy(filename, de->d_name);
		open_device(devname, print_flags);
	}
	closedir(dir);
	return 0;
}


static int read_notify(const char *dirname, int nfd, int print_flags)
{
	int res;
	char devname[PATH_MAX];
	char *filename;
	char event_buf[512];
	int event_size;
	int event_pos = 0;
	struct inotify_event *event;

	res = read(nfd, event_buf, sizeof(event_buf));
	if(res < (int)sizeof(*event)) {
		if(errno == EINTR)
			return 0;
		fprintf(stderr, "could not get event, %s\n", strerror(errno));
		return 1;
	}
	printf("got %d bytes of event information\n", res);

	strcpy(devname, dirname);
	filename = devname + strlen(devname);
	*filename++ = '/';

	while(res >= (int)sizeof(*event)) {
		event = (struct inotify_event *)(event_buf + event_pos);
		printf("%d: %08x \"%s\"\n", event->wd, event->mask, event->len ? event->name : "");
		if(event->len) {
			strcpy(filename, event->name);
			if(event->mask & IN_CREATE) {
				open_device(devname, print_flags);
			}
			else {
				close_device(devname, print_flags);
			}
		}
		event_size = sizeof(*event) + event->len;
		res -= event_size;
		event_pos += event_size;
	}
	return 0;
}


int main()
{
	int i;
	int res;
	struct input_event event;
	const char* device_path = "/dev/input";
	const char* output_path = "/mnt/sdcard/out";
	int write_count;
	int debug_print;
	timeval first_time;

	write_count = 0;
	debug_print = 0;

	first_time.tv_sec = -1;
	first_time.tv_usec = -1;

	nfds = 1;
	ufds = (struct pollfd*)calloc(0, sizeof(ufds[0]));
	ufds[0].fd = inotify_init();
	ufds[0].events = POLLIN;

	res = inotify_add_watch(ufds[0].fd, device_path, IN_DELETE | IN_CREATE);
	if(res < 0) {
		fprintf(stderr, "could not add watch for %s, %s\n", device_path, strerror(errno));
		return 1;
	}
	
	res = scan_dir(device_path, debug_print);
	//res = open_device(device, 0);
	if(res < 0) {
		fprintf(stderr, "scan dir failed for %s\n", device_path);
		return 1;
	}

#if 1
	if( add_signal() ) {
		fprintf(stderr, "add signal failure \n");
		return 1;
	}
#endif

	if(event_file_open(output_path)){
		fprintf(stderr, "open output file failure \n");
		return 1;
	}


	while(1) {
		poll(ufds, nfds, -1);
		if(ufds[0].revents & POLLIN) {
			read_notify(device_path, ufds[0].fd, debug_print);
		}

		for(i = 1; i < nfds; i++) {
			if(ufds[i].revents) {
				if(ufds[i].revents & POLLIN) {
					write_count++;
					res = read(ufds[i].fd, &event, sizeof(event));

					if(first_time.tv_sec == -1) {
						first_time = event.time;
					}
					event.time.tv_sec -= first_time.tv_sec;

					if(event.time.tv_usec < first_time.tv_usec) {
						event.time.tv_sec--;
						event.time.tv_usec += 1000000; /* + 1s */
					}
					event.time.tv_usec -= first_time.tv_usec;

					if(res < (int)sizeof(event)) {
						fprintf(stderr, "could not get event\n");
						return 1;
					}

					#if 0
					if(0) // show time
						printf("[%8ld.%06ld] ", event.time.tv_sec, event.time.tv_usec);
					if(0) // show dev name
						printf("%s: ", device_names[i]);
					#endif

					#if 1 /* Debug only */
					printf("[%8ld.%06ld] %d, %d %d %d\n", 
							event.time.tv_sec, event.time.tv_usec,
							i,
							event.type, event.code, event.value);
					#endif

					//event_file_write(&event, (unsigned char)i);
				}

			}
		}

		if(close_signal) {
			break;
		}
	}

	event_file_close();

	#if 1
	printf("write %d events...\n", write_count);
	printf("terminate...\n");
	#endif

	return 0;
}
